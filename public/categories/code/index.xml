<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code on My New Hugo Site</title><link>http://localhost:1313/categories/code/</link><description>Recent content in Code on My New Hugo Site</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 11 Feb 2024 21:49:07 +0000</lastBuildDate><atom:link href="http://localhost:1313/categories/code/index.xml" rel="self" type="application/rss+xml"/><item><title>Had some fun today learning about WFP drivers</title><link>http://localhost:1313/docs/legacy/2024-02-11-windows-filtering-platform-wfp-overview/</link><pubDate>Sun, 11 Feb 2024 21:49:07 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2024-02-11-windows-filtering-platform-wfp-overview/</guid><description>WFP is a network packet filtering framework provided by Windows. It provides API support for both user mode and kernel mode, and can be used to easily implement network packet interception/editing, commonly used to implement firewalls, speed control and intrusion detection.
The WFP architecture is shown in the figure above. Although it provides user mode and kernel mode interfaces, the actual work is done in the kernel layer.
The main part of the WFP framework is the Filter Engine in the figure, which interacts and operates with the operating system’s network stack, and can process data in the network stack to implement data filtering and other functions.</description></item><item><title>List services scheduled for retirement in Azure Graph / KQL</title><link>http://localhost:1313/docs/legacy/2024-02-09-kql-query-microsoft-services-retirement/</link><pubDate>Fri, 09 Feb 2024 11:34:55 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2024-02-09-kql-query-microsoft-services-retirement/</guid><description>Below you will find a KQL query to list services that are about to be retired by Microsoft.
This is intended to check against the list of resources announced at
https://azure.microsoft.com/updates/?updateType=retirements
As a foundation, I used this workbook:
&amp;lt;https://github.com/microsoft/Application-Insights-Workbooks/blob/master/Workbooks/Azure%20Advisor/AzureServiceRetirement/Azure%20Services%20Retirement.workbook &amp;gt;
from which I extracted the KQL.</description></item><item><title>How to Create Your Own Custom Filter Driver for Windows</title><link>http://localhost:1313/docs/legacy/2024-02-01-create-custom-filter-driver-windows/</link><pubDate>Thu, 01 Feb 2024 01:25:46 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2024-02-01-create-custom-filter-driver-windows/</guid><description>A Windows Filter Driver is a specialized driver within the Microsoft Windows operating system. It serves as a mechanism to intercept and modify the behavior of specific system operations. These drivers function at a low level within the operating system, enabling the monitoring or alteration of interactions between the OS and its hardware or software components. Filter drivers essentially “filter” I/O requests (input/output), intercepting and potentially modifying them for a particular device or file system.</description></item><item><title>PowerShell: Create a New Domain Admin User</title><link>http://localhost:1313/docs/legacy/2023-12-01-recover-azure-vm-domain-admin-access/</link><pubDate>Fri, 01 Dec 2023 09:05:10 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2023-12-01-recover-azure-vm-domain-admin-access/</guid><description>If you have deployed a Windows Virtual Machine from the Azure Marketplace that comes with a domain controller pre-installed, and your local domain admin password has expired, you will not be able to recover access using Azure’s built-in password recovery tool, as it is not supported on domain controllers. However, you can use the script provided below as a Run Command to create a new domain admin user and regain access:</description></item><item><title>PowerShell: Analyzing Virtual Machine Activity Logs to Determine Uptime and Downtime</title><link>http://localhost:1313/docs/legacy/2023-10-12-azure-vm-log-analysis-powershell/</link><pubDate>Thu, 12 Oct 2023 10:29:25 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2023-10-12-azure-vm-log-analysis-powershell/</guid><description>One common task many administrators often face is monitoring and analyzing virtual machine activity logs to determine uptime and downtime.
Here is a script that can help you getting started:
Write-Host &amp;ldquo;Fetching activity logs for the specified VM in the last $daysAgo days&amp;hellip;&amp;rdquo; $logs = Get-AzLog -ResourceGroupName $resourceGroupName -StartTime (Get-Date).AddDays(-$daysAgo)
Write-Host &amp;ldquo;Filtering logs for VM start, stop, and deallocate actions that have &amp;lsquo;Succeeded&amp;rsquo; status&amp;hellip;&amp;rdquo; $relevantLogs = $logs | Where-Object { ( $.</description></item><item><title>PowerShell: Script-Based Workaround for Renaming Azure VMs and Switching to Unsupported Sizes</title><link>http://localhost:1313/docs/legacy/2023-10-10-bypassing-azure-vm-limitations-script-based-solution/</link><pubDate>Tue, 10 Oct 2023 14:48:05 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2023-10-10-bypassing-azure-vm-limitations-script-based-solution/</guid><description>Inability to change the name of an existing Azure VM. Constraints when resizing VMs, specifically: You can’t resize a VM size that has a local temp disk to a VM size without one, and vice versa. The only combinations allowed for resizing are:
VM (with no local temp disk) -&amp;gt; VM (with no local temp disk) VM (with local temp disk) -&amp;gt; VM (with local temp disk) Workaround # Below is a PowerShell script that allows you to circumvent the VM name and size restrictions while keeping the disk, network interface card, and extensions in place.</description></item><item><title>C++: Detecting Hypervisor Presence Using CPUID Timing</title><link>http://localhost:1313/docs/legacy/2023-10-05-detecting-hypervisor-presence-using-cpuid-in-cpp/</link><pubDate>Thu, 05 Oct 2023 21:12:44 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2023-10-05-detecting-hypervisor-presence-using-cpuid-in-cpp/</guid><description>The CPUID instruction is a processor supplementary instruction for the x86 architecture. It is used to query the CPU for information about its features and capabilities.
How VM-Exits Work with CPUID # The guest operating system executes the CPUID instruction. The CPU generates a VM-exit interrupt. The hypervisor intercepts the VM-exit interrupt and takes control of the VM. The hypervisor executes the CPUID instruction and returns the results to the guest operating system.</description></item><item><title>Rest API: Azure REST API POC</title><link>http://localhost:1313/docs/legacy/2023-09-28-azure-rest-api-powershell-poc/</link><pubDate>Thu, 28 Sep 2023 13:20:38 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2023-09-28-azure-rest-api-powershell-poc/</guid><description>This PowerShell script serves as a Proof of Concept for teaching how to interact with Azure resources using REST API calls via PowerShell. It automates a series of Azure resource management tasks, providing a hands-on example for those looking to understand Azure REST API operations.
Operations Covered: # Create a Managed Disk: Demonstrates how to allocate a managed disk in Azure. Create a Virtual Network (VNet): Shows the steps to set up a virtual network.</description></item><item><title>C++: Memory Leaker Tool &amp;#8211; VeryLeakyCauldron</title><link>http://localhost:1313/docs/legacy/2023-09-22-simulating-memory-leaks-in-c-with-the-c-memory-leaker-tool-veryleakycauldron/</link><pubDate>Fri, 22 Sep 2023 14:09:42 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2023-09-22-simulating-memory-leaks-in-c-with-the-c-memory-leaker-tool-veryleakycauldron/</guid><description>Memory leaks are a common problem in programming. They can occur when memory is allocated and then not properly deallocated, leading to a waste of resources and potentially causing performance problems.
This C++ Memory Leaker tool is a simple tool that can be used to simulate memory leaks. It works by allocating a specified amount of memory and then not deallocating it. This can be done manually or automatically at a specified interval.</description></item><item><title>PowerShell: Download and Use AzCopy (Windows) to Upload Files to Azure Blob Storage</title><link>http://localhost:1313/docs/legacy/2023-09-20-powershell-download-and-use-azcopy-to-upload-files-to-azure-blob-storage/</link><pubDate>Wed, 20 Sep 2023 15:22:09 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2023-09-20-powershell-download-and-use-azcopy-to-upload-files-to-azure-blob-storage/</guid><description>AzCopy is a powerful command-line utility that allows for streamlined data transfer to and from Azure Blob, File, and Table storage.
Script below will download, install, and utilize AzCopy on a Windows machine to upload a file to Azure Blob Storage.
$azCopyUrl = &amp;ldquo;https://aka.ms/downloadazcopy-v10-windows" $destination = &amp;ldquo;C:\Temp\AzCopy.zip&amp;rdquo;
Ensure C:\Temp exists # if (-not (Test-Path &amp;ldquo;C:\Temp&amp;rdquo;)) { New-Item -ItemType Directory -Path &amp;ldquo;C:\Temp&amp;rdquo; -Force } Invoke-WebRequest -Uri $azCopyUrl -OutFile $destination Expand-Archive -Path $destination -DestinationPath &amp;ldquo;C:\Temp\azcopy&amp;rdquo; $azCopyExe = Get-ChildItem -Path &amp;ldquo;C:\Temp\azcopy&amp;rdquo; -Recurse -Filter &amp;ldquo;azcopy.</description></item><item><title>PowerShell: Automating Windows Crash Control Configuration</title><link>http://localhost:1313/docs/legacy/2023-09-20-powershell-automating-windows-crash-control-configuration/</link><pubDate>Wed, 20 Sep 2023 14:29:42 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2023-09-20-powershell-automating-windows-crash-control-configuration/</guid><description>This script aims to automate the task of configuring several settings under the Windows CrashControl registry path. The configurations include specifying memory dump paths, enabling auto-reboot, setting logging levels, and more.
Reference documentation:
https://learn.microsoft.com/en-us/troubleshoot/windows-client/performance/generate-a-kernel-or-complete-crash-dump
try { Set-ItemProperty -Path $registryPath -Name &amp;ldquo;AutoReboot&amp;rdquo; -Value 1 Set-ItemProperty -Path $registryPath -Name &amp;ldquo;CrashDumpEnabled&amp;rdquo; -Value 1 Set-ItemProperty -Path $registryPath -Name &amp;ldquo;DisableEmoticon&amp;rdquo; -Value 1 Set-ItemProperty -Path $registryPath -Name &amp;ldquo;DumpFile&amp;rdquo; -Value $dumpFilePath Set-ItemProperty -Path $registryPath -Name &amp;ldquo;DumpLogLevel&amp;rdquo; -Value 0 Set-ItemProperty -Path $registryPath -Name &amp;ldquo;EnableLogFile&amp;rdquo; -Value 1 Set-ItemProperty -Path $registryPath -Name &amp;ldquo;LogEvent&amp;rdquo; -Value 1 Set-ItemProperty -Path $registryPath -Name &amp;ldquo;MinidumpDir&amp;rdquo; -Value $minidumpDir</description></item><item><title>PowerShell: Create a NAT VMSwitch on Hyper-V</title><link>http://localhost:1313/docs/legacy/2023-09-18-powershell-create-a-nat-vmswitch-on-hyper-v/</link><pubDate>Mon, 18 Sep 2023 09:38:37 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2023-09-18-powershell-create-a-nat-vmswitch-on-hyper-v/</guid><description>https://learn.microsoft.com/en-us/virtualization/hyper-v-on-windows/user-guide/setup-nat-network
Live migration in clustered scenario won’t work for VMs using this NAT.
Quick migration will work.
Define the NAT Switch Name and NAT Configuration Parameters # $switchName = &amp;ldquo;NATSwitch&amp;rdquo; $natSubnet = &amp;ldquo;192.168.100.0/24&amp;rdquo; $gatewayAddress = &amp;ldquo;192.168.100.1&amp;rdquo; $netAdapaterName = &amp;ldquo;vEthernet (&amp;quot;+$switchName+&amp;rdquo;)&amp;quot;
Create a new virtual switch # New-VMSwitch -SwitchName $switchName -SwitchType Internal
Retrieve the actual Network Adapter for the created switch # $netAdapter = Get-NetAdapter -Name $netAdapaterName
Set the IP address on the NAT Gateway (the virtual switch) # New-NetIPAddress -IPAddress $gatewayAddress -PrefixLength 24 -InterfaceIndex $netAdapter.</description></item><item><title>PowerShell: Download ISO from MSDN Directly to the Server/VM</title><link>http://localhost:1313/docs/legacy/2023-09-18-powershell-download-iso-from-msdn-directly-to-the-server-vm/</link><pubDate>Mon, 18 Sep 2023 09:22:23 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2023-09-18-powershell-download-iso-from-msdn-directly-to-the-server-vm/</guid><description>Define the destination path where the ISO file will be saved # $destinationPath = &amp;ldquo;C:\Temp\WS2012.iso&amp;rdquo;
Download the ISO file # Invoke-WebRequest -Uri $isoUrl -OutFile $destinationPath
Output the location where the ISO file has been saved # Write-Host &amp;ldquo;ISO file has been downloaded to $destinationPath&amp;rdquo;&amp;quot; role=&amp;ldquo;button&amp;rdquo; style=&amp;ldquo;color:#D4D4D4;display:none&amp;rdquo; tabindex=&amp;ldquo;0&amp;rdquo;&amp;gt;``` # Define the URL of the ISO file $isoUrl = &amp;ldquo;https://myvs.download.prss.microsoft.com/yourisofilepath.iso" # Define the destination path where the ISO file will be saved $destinationPath = &amp;ldquo;C:\Temp\WS2012.</description></item><item><title>PowerShell: Gather DNS Server Logs from Windows</title><link>http://localhost:1313/docs/legacy/2023-09-13-powershell-gather-dns-server-logs-from-windows/</link><pubDate>Wed, 13 Sep 2023 14:25:29 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2023-09-13-powershell-gather-dns-server-logs-from-windows/</guid><description> if (-not (Test-Path $destDirectory)) { New-Item -ItemType Directory -Path $destDirectory }
Get-WinEvent -LogName &amp;lsquo;DNS Server&amp;rsquo; | Export-Csv -Path &amp;ldquo;$destDirectory\DNSServerEvents.csv&amp;rdquo; -NoTypeInformation
dnscmd /info &amp;gt; &amp;ldquo;$destDirectory\DNSConfig.txt&amp;rdquo;
Write-Output &amp;ldquo;Diagnostic logs have been gathered and saved to $destDirectory&amp;rdquo; &amp;quot; role=&amp;ldquo;button&amp;rdquo; style=&amp;ldquo;color:#D4D4D4;display:none&amp;rdquo; tabindex=&amp;ldquo;0&amp;rdquo;&amp;gt;``` $destDirectory = &amp;ldquo;C:\DNSLogs&amp;rdquo; if (-not (Test-Path $destDirectory)) { New-Item -ItemType Directory -Path $destDirectory } Get-WinEvent -LogName &amp;lsquo;DNS Server&amp;rsquo; | Export-Csv -Path &amp;quot;$destDirectory\DNSServerEvents.csv&amp;quot; -NoTypeInformation dnscmd /info &amp;gt; &amp;quot;$destDirectory\DNSConfig.txt&amp;quot; Write-Output &amp;ldquo;Diagnostic logs have been gathered and saved to $destDirectory&amp;quot; &amp;lt;/div&amp;gt;</description></item><item><title>Powershell: Tracking Last Domain Login Events on Azure VMs</title><link>http://localhost:1313/docs/legacy/2023-09-11-tracking-last-domain-login-events-on-azure-vms-a-handy-script/</link><pubDate>Mon, 11 Sep 2023 07:29:10 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2023-09-11-tracking-last-domain-login-events-on-azure-vms-a-handy-script/</guid><description>When managing virtual machines (VMs) in a cloud environment like Azure, it’s crucial to monitor user activities for various reasons. Whether it’s for auditing, security, or simply to track unused resources, knowing the last time someone logged in can provide valuable insights. If you’re not sure whether anyone is even logging into your Azure VM, you can check the last domain login events without breaking a sweat. All you need is PowerShell and Azure’s “Run Command” feature.</description></item><item><title>C#: Working with Azure IMDS</title><link>http://localhost:1313/docs/legacy/2023-08-22-c-working-with-azure-imds/</link><pubDate>Tue, 22 Aug 2023 13:58:28 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2023-08-22-c-working-with-azure-imds/</guid><description>class Program { static void Main(string[] args) { //Identify Storage Type Using Azure Metadata Service string url = &amp;ldquo;http://169.254.169.254/metadata/instance?api-version=2021-02-01&amp;rdquo;; WebClient client = new WebClient(); client.Headers.Add(&amp;ldquo;Metadata&amp;rdquo;, &amp;ldquo;true&amp;rdquo;);
try { string response = client.DownloadString(url); dynamic data = JsonConvert.DeserializeObject(response); string storageProfile = data.compute.storageProfile.ToString(); dynamic storageData = JsonConvert.DeserializeObject(storageProfile); string osDiskName = storageData.osDisk.name; string osDiskCaching = storageData.osDisk.caching; string osDiskSize = storageData.osDisk.diskSizeGB; string writeAcceleratorEnabled = storageData.osDisk.writeAcceleratorEnabled; string datadisks = storageData.dataDisks.ToString(); Console.WriteLine(&amp;quot;OS Disk Name: &amp;quot; + osDiskName); Console.</description></item><item><title>C#: Check if service exists via WMI</title><link>http://localhost:1313/docs/legacy/2023-08-22-c-check-if-service-exists-via-wmi/</link><pubDate>Tue, 22 Aug 2023 13:55:49 +0000</pubDate><guid>http://localhost:1313/docs/legacy/2023-08-22-c-check-if-service-exists-via-wmi/</guid><description>namespace debug { internal class Program { static void Main(string[] args) { string query = &amp;ldquo;select * from Win32_Service where name=&amp;lsquo;W3svc&amp;rsquo;&amp;rdquo;; try { using (ManagementObjectSearcher searcher = new ManagementObjectSearcher(query)) { ManagementObjectCollection services = searcher.Get(); if (services.Count == 0) { Console.WriteLine(&amp;ldquo;IIS Service not found.&amp;rdquo;); } else { foreach (ManagementObject service in searcher.Get()) { string name = service[&amp;ldquo;Name&amp;rdquo;].ToString(); string displayName = service[&amp;ldquo;DisplayName&amp;rdquo;].ToString(); string status = service[&amp;ldquo;State&amp;rdquo;].ToString();
Console.WriteLine(&amp;quot;Service Name: &amp;quot; + name); Console.</description></item></channel></rss>